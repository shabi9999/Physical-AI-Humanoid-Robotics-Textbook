"use strict";(globalThis.webpackChunkmy_website=globalThis.webpackChunkmy_website||[]).push([[4495],{352:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>d,default:()=>h,frontMatter:()=>l,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"module1/ch3-urdf-model","title":"Chapter 3: Creating Humanoid URDF Models","description":"Learning Objectives","source":"@site/docs/module1/chapter3-urdf-model.md","sourceDirName":"module1","slug":"/module1/ch3-urdf-model","permalink":"/Physical-AI-Humanoid-Robotics-Textbook/docs/module1/ch3-urdf-model","draft":false,"unlisted":false,"editUrl":"https://github.com/shabi9999/Physical-AI-Humanoid-Robotics-Textbook/tree/main/my-website/docs/module1/chapter3-urdf-model.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3,"title":"Chapter 3: Creating Humanoid URDF Models","module":1,"chapter":3,"id":"ch3-urdf-model","learning_objectives":["Understand URDF as the ROS 2 standard for robot description","Define links (rigid bodies) and joints (connections) in XML","Create and validate humanoid robot models"],"prerequisites":["Chapters 1-2 completion (recommended)","Basic XML knowledge","ROS 2 Humble environment"],"related_chapters":["chapter1-ros2-core","chapter2-agent-bridge"],"keywords":["URDF","robot modeling","XML","kinematics","humanoid"],"difficulty":"Beginner-Intermediate","estimated_reading_time":"17 minutes","estimated_word_count":2800,"created_at":"2025-12-09","chunk_count":6,"searchable_terms":["URDF","links","joints","humanoid","robot structure"]},"sidebar":"docs","previous":{"title":"Chapter 2: Bridging Python Agents to ROS 2","permalink":"/Physical-AI-Humanoid-Robotics-Textbook/docs/module1/ch2-agent-bridge"},"next":{"title":"Module 2: The Digital Twin (Gazebo & Unity Simulation)","permalink":"/Physical-AI-Humanoid-Robotics-Textbook/docs/module2/intro"}}');var r=i(4848),t=i(8453);const l={sidebar_position:3,title:"Chapter 3: Creating Humanoid URDF Models",module:1,chapter:3,id:"ch3-urdf-model",learning_objectives:["Understand URDF as the ROS 2 standard for robot description","Define links (rigid bodies) and joints (connections) in XML","Create and validate humanoid robot models"],prerequisites:["Chapters 1-2 completion (recommended)","Basic XML knowledge","ROS 2 Humble environment"],related_chapters:["chapter1-ros2-core","chapter2-agent-bridge"],keywords:["URDF","robot modeling","XML","kinematics","humanoid"],difficulty:"Beginner-Intermediate",estimated_reading_time:"17 minutes",estimated_word_count:2800,created_at:"2025-12-09",chunk_count:6,searchable_terms:["URDF","links","joints","humanoid","robot structure"]},d="Chapter 3: Creating Humanoid URDF Models",o={},c=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Section 1: Introduction to URDF",id:"section-1-introduction-to-urdf",level:2},{value:"Why URDF?",id:"why-urdf",level:3},{value:"Section 2: Links and Joints",id:"section-2-links-and-joints",level:2},{value:"Links: Rigid Bodies",id:"links-rigid-bodies",level:3},{value:"Joints: Connections",id:"joints-connections",level:3},{value:"URDF Tree Structure: A Humanoid Robot Example",id:"urdf-tree-structure-a-humanoid-robot-example",level:3},{value:"Section 3: Humanoid Structure",id:"section-3-humanoid-structure",level:2},{value:"Basic Anatomy",id:"basic-anatomy",level:3},{value:"Our Model (simple_humanoid.urdf)",id:"our-model-simple_humanoidurdf",level:3},{value:"Section 4: Hands-On Lab",id:"section-4-hands-on-lab",level:2},{value:"Step 1: Parse URDF (No ROS 2 Required)",id:"step-1-parse-urdf-no-ros-2-required",level:3},{value:"Step 2: Validate with ROS 2",id:"step-2-validate-with-ros-2",level:3},{value:"Step 3: Modify and Re-validate",id:"step-3-modify-and-re-validate",level:3},{value:"Section 5: Troubleshooting",id:"section-5-troubleshooting",level:2},{value:"Cross-Module Connections",id:"cross-module-connections",level:2},{value:"Key Takeaways",id:"key-takeaways",level:2},{value:"Acronym Reference",id:"acronym-reference",level:2},{value:"Resources",id:"resources",level:2}];function a(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"chapter-3-creating-humanoid-urdf-models",children:"Chapter 3: Creating Humanoid URDF Models"})}),"\n",(0,r.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,r.jsx)(n.p,{children:"By the end of this chapter, you will:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Understand URDF (Unified Robot Description Format) as XML-based robot description"}),"\n",(0,r.jsx)(n.li,{children:"Define links (rigid bodies) and joints (connections)"}),"\n",(0,r.jsx)(n.li,{children:"Create a humanoid robot model with multiple limbs"}),"\n",(0,r.jsx)(n.li,{children:"Validate URDF files using ROS 2 tools"}),"\n",(0,r.jsx)(n.li,{children:"Visualize URDF models in RViz"}),"\n",(0,r.jsx)(n.li,{children:"Modify joint parameters and re-validate"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Chapters 1-2 Completion"})," (recommended)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Basic XML Knowledge"}),": Understanding of tags and nesting"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Environment"}),": Python 3.8+, ROS 2 Humble"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"section-1-introduction-to-urdf",children:"Section 1: Introduction to URDF"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"URDF"})," = Unified Robot Description Format"]}),"\n",(0,r.jsx)(n.p,{children:"An XML file that describes:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Structure"}),": How links (rigid bodies) connect via joints"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Physics"}),": Mass, inertia, friction"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Appearance"}),": Visual geometry for RViz"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Collision"}),": Shapes for planning"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"why-urdf",children:"Why URDF?"}),"\n",(0,r.jsxs)(n.p,{children:["URDF is the ",(0,r.jsx)(n.strong,{children:"ROS 2 standard"})," for robot models:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Used by Gazebo, CoppeliaSim (simulation)"}),"\n",(0,r.jsx)(n.li,{children:"Used by MoveIt! (motion planning)"}),"\n",(0,r.jsx)(n.li,{children:"Used by RViz (visualization)"}),"\n",(0,r.jsx)(n.li,{children:"Human-readable XML format"}),"\n"]}),"\n",(0,r.jsx)(n.mermaid,{value:'graph TB\n    A["URDF File<br/>(XML format)"]\n    A --\x3e|Parsed by| B["ROS 2 Tools"]\n    B --\x3e|Used by| C["Gazebo<br/>(Physics Sim)"]\n    B --\x3e|Used by| D["RViz<br/>(Visualization)"]\n    B --\x3e|Used by| E["MoveIt<br/>(Motion Planning)"]\n    B --\x3e|Used by| F["Isaac Sim<br/>(Rendering)"]\n    style A fill:#fff9c4\n    style C fill:#c8e6c9\n    style D fill:#b3e5fc\n    style E fill:#f8bbd0\n    style F fill:#ffe0b2'}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"section-2-links-and-joints",children:"Section 2: Links and Joints"}),"\n",(0,r.jsx)(n.h3,{id:"links-rigid-bodies",children:"Links: Rigid Bodies"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'<link name="torso_link">\n  <inertial>\n    <mass value="20.0"/>\n    <inertia ixx="0.5" ixy="0" ixz="0" iyy="0.5" iyz="0" izz="0.3"/>\n  </inertial>\n  <visual>\n    <geometry>\n      <cylinder radius="0.15" length="0.6"/>\n    </geometry>\n  </visual>\n  <collision>\n    <geometry>\n      <cylinder radius="0.15" length="0.6"/>\n    </geometry>\n  </collision>\n</link>\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Properties"}),": Inertial (physics), Visual (appearance), Collision (planning)"]}),"\n",(0,r.jsx)(n.h3,{id:"joints-connections",children:"Joints: Connections"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'<joint name="torso_to_shoulder" type="revolute">\n  <parent link="torso_link"/>\n  <child link="shoulder_link"/>\n  <origin xyz="0.25 0.2 0.4" rpy="0 0 0"/>\n  <axis xyz="0 1 0"/>\n  <limit lower="-1.57" upper="1.57" effort="10" velocity="1.0"/>\n</joint>\n'})}),"\n",(0,r.jsx)(n.h3,{id:"urdf-tree-structure-a-humanoid-robot-example",children:"URDF Tree Structure: A Humanoid Robot Example"}),"\n",(0,r.jsxs)(n.p,{children:["Every URDF describes a ",(0,r.jsx)(n.strong,{children:"kinematic tree"})," where links are connected by joints:"]}),"\n",(0,r.jsx)(n.mermaid,{value:'graph TD\n    W["world<br/>(fixed)"]\n    W --\x3e|fixed| B["base_link<br/>(torso)"]\n\n    B --\x3e|revolute| SL["shoulder_link"]\n    SL --\x3e|revolute| UA["upper_arm_link"]\n    UA --\x3e|revolute| FA["forearm_link"]\n    FA --\x3e|revolute| H["hand_link"]\n\n    B --\x3e|revolute| LH["left_hip_link"]\n    LH --\x3e|revolute| LT["left_thigh_link"]\n    LT --\x3e|revolute| LC["left_calf_link"]\n    LC --\x3e|revolute| LF["left_foot_link"]\n\n    B --\x3e|revolute| RH["right_hip_link"]\n    RH --\x3e|revolute| RT["right_thigh_link"]\n    RT --\x3e|revolute| RC["right_calf_link"]\n    RC --\x3e|revolute| RF["right_foot_link"]\n\n    style W fill:#ffcccc\n    style B fill:#ffffcc\n    style SL fill:#ccffcc\n    style H fill:#ccffcc\n    style LH fill:#ccccff\n    style LF fill:#ccccff\n    style RH fill:#ffccff\n    style RF fill:#ffccff'}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Key concept"}),": URDF describes the robot's ",(0,r.jsx)(n.strong,{children:"skeleton"}),"\u2014how body parts connect and can move."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Links"})," = rectangular nodes (rigid bodies with mass and geometry)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Joints"})," = arrows connecting links (revolute, prismatic, or fixed)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Tree structure"})," = No loops (valid kinematic chain)"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Joint Types"}),": revolute (rotation), prismatic (linear), fixed (rigid)"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"section-3-humanoid-structure",children:"Section 3: Humanoid Structure"}),"\n",(0,r.jsx)(n.h3,{id:"basic-anatomy",children:"Basic Anatomy"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"          HEAD\n           |\nLEFT ARM--TORSO--RIGHT ARM\n           |\nLEFT LEG--HIPS--RIGHT LEG\n"})}),"\n",(0,r.jsx)(n.h3,{id:"our-model-simple_humanoidurdf",children:"Our Model (simple_humanoid.urdf)"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"15 links"})," (including base)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"14 joints"})," (12 revolute, 2 fixed)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"~40 kg"})," total mass"]}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"12 degrees of freedom"})}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Structure"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Torso: main body (20 kg)"}),"\n",(0,r.jsx)(n.li,{children:"Head: attached to torso (3 kg)"}),"\n",(0,r.jsx)(n.li,{children:"2 Arms: shoulder + elbow + wrist (3 joints each)"}),"\n",(0,r.jsx)(n.li,{children:"2 Legs: hip + knee + ankle (3 joints each)"}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"section-4-hands-on-lab",children:"Section 4: Hands-On Lab"}),"\n",(0,r.jsx)(n.h3,{id:"step-1-parse-urdf-no-ros-2-required",children:"Step 1: Parse URDF (No ROS 2 Required)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"cd examples/module1/chapter3\npython3 visualize_urdf.py\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Output shows"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Robot structure (15 links, 14 joints)"}),"\n",(0,r.jsx)(n.li,{children:"Link properties (inertial, visual, collision)"}),"\n",(0,r.jsx)(n.li,{children:"Kinematic tree hierarchy"}),"\n",(0,r.jsx)(n.li,{children:"Validation result"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"step-2-validate-with-ros-2",children:"Step 2: Validate with ROS 2"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"source /opt/ros/humble/setup.bash\ncheck_urdf simple_humanoid.urdf\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Confirms"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"\x05 Valid XML syntax"}),"\n",(0,r.jsx)(n.li,{children:"\x05 No kinematic cycles"}),"\n",(0,r.jsx)(n.li,{children:"\x05 All links and joints properly connected"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"step-3-modify-and-re-validate",children:"Step 3: Modify and Re-validate"}),"\n",(0,r.jsxs)(n.p,{children:["Edit joint limits in ",(0,r.jsx)(n.code,{children:"simple_humanoid.urdf"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'\x3c!-- Increase shoulder range from 90\xb0 to 120\xb0 --\x3e\n<limit lower="-2.09" upper="2.09" effort="10" velocity="1.0"/>\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Re-validate: ",(0,r.jsx)(n.code,{children:"python3 visualize_urdf.py"})]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"section-5-troubleshooting",children:"Section 5: Troubleshooting"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Issue"}),(0,r.jsx)(n.th,{children:"Solution"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"XML syntax errors"}),(0,r.jsx)(n.td,{children:"Check for unclosed tags, proper nesting"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Missing link reference"}),(0,r.jsx)(n.td,{children:"Ensure all parent/child links are defined"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Invalid joint axis"}),(0,r.jsx)(n.td,{children:"Axis must be unit vector (length = 1)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Invalid joint type"}),(0,r.jsx)(n.td,{children:"Use: revolute, continuous, prismatic, fixed"})]})]})]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"cross-module-connections",children:"Cross-Module Connections"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Module 1 \u2192 Module 2 (Digital Twin)"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Your URDF models load into Gazebo for physics-based simulation"}),"\n",(0,r.jsx)(n.li,{children:"The simulator respects joint limits and mass properties you defined"}),"\n",(0,r.jsx)(n.li,{children:"Simulated sensor data (camera, lidar) is attached to links via URDF"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Module 1 \u2192 Module 3 (Perception)"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Isaac Sim imports URDF models for photorealistic rendering"}),"\n",(0,r.jsx)(n.li,{children:"VSLAM nodes track humanoid pose relative to the kinematic tree structure"}),"\n",(0,r.jsx)(n.li,{children:"Nav2 path planning considers robot dimensions defined in URDF"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Module 1 \u2192 Module 4 (VLA Pipeline)"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Action servers command joints and links through ROS 2"}),"\n",(0,r.jsx)(n.li,{children:"Trajectory planning respects joint limits from URDF"}),"\n",(0,r.jsx)(n.li,{children:"Perception systems understand humanoid structure via URDF data"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"URDF is XML"}),": Hierarchical, text-based format"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Links are bodies"}),": Have mass, inertia, geometry"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Joints connect links"}),": Define motion and constraints"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Tree structure"}),": No cycles (valid robot)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Validation matters"}),": Always use check_urdf"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"ROS 2 standard"}),": Used everywhere in Modules 2-4"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"acronym-reference",children:"Acronym Reference"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Acronym"}),(0,r.jsx)(n.th,{children:"Full Name"}),(0,r.jsx)(n.th,{children:"Definition"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"URDF"})}),(0,r.jsx)(n.td,{children:"Unified Robot Description Format"}),(0,r.jsx)(n.td,{children:"XML-based format for describing robot structure and properties"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"XML"})}),(0,r.jsx)(n.td,{children:"Extensible Markup Language"}),(0,r.jsx)(n.td,{children:"Hierarchical text format using tags for data structure"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"DOF"})}),(0,r.jsx)(n.td,{children:"Degrees of Freedom"}),(0,r.jsx)(n.td,{children:"Number of independent ways a robot can move"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"RViz"})}),(0,r.jsx)(n.td,{children:"ROS Visualization"}),(0,r.jsx)(n.td,{children:"3D visualization tool for ROS 2 robots and sensor data"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Gazebo"})}),(0,r.jsx)(n.td,{children:"Gazebo Simulator"}),(0,r.jsx)(n.td,{children:"Physics-based robot simulation environment"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"MoveIt"})}),(0,r.jsx)(n.td,{children:"MoveIt Motion Planning"}),(0,r.jsx)(n.td,{children:"Robot motion and manipulation planning framework"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"kg"})}),(0,r.jsx)(n.td,{children:"Kilogram"}),(0,r.jsx)(n.td,{children:"Unit of mass"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"rad"})}),(0,r.jsx)(n.td,{children:"Radian"}),(0,r.jsx)(n.td,{children:"Unit of angular measurement (1 radian \u2248 57.3 degrees)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Hz"})}),(0,r.jsx)(n.td,{children:"Hertz"}),(0,r.jsx)(n.td,{children:"Unit of frequency (cycles per second)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"API"})}),(0,r.jsx)(n.td,{children:"Application Programming Interface"}),(0,r.jsx)(n.td,{children:"Set of functions for software interaction"})]})]})]}),"\n",(0,r.jsx)(n.h2,{id:"resources",children:"Resources"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://wiki.ros.org/urdf/XML",children:"URDF XML Specification"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://docs.ros.org/en/humble/Tutorials/Intermediate/URDF/URDF-Main.html",children:"ROS 2 URDF Tutorials"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"http://gazebosim.org/tutorials?tut=build_model",children:"Gazebo URDF Guide"})}),"\n",(0,r.jsxs)(n.li,{children:["Chapter 3 Examples: ",(0,r.jsx)(n.code,{children:"examples/module1/chapter3/"})]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>l,x:()=>d});var s=i(6540);const r={},t=s.createContext(r);function l(e){const n=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);