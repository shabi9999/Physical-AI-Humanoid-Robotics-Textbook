"use strict";(globalThis.webpackChunkmy_website=globalThis.webpackChunkmy_website||[]).push([[4117],{6770:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>a});const s=JSON.parse('{"id":"module2/ch2-gazebo-physics","title":"Chapter 2: Gazebo Physics Engine","description":"How Physics Engines Work","source":"@site/docs/module2/chapter2-gazebo-physics.md","sourceDirName":"module2","slug":"/module2/ch2-gazebo-physics","permalink":"/Physical-AI-Humanoid-Robotics-Textbook/docs/module2/ch2-gazebo-physics","draft":false,"unlisted":false,"editUrl":"https://github.com/shabi9999/Physical-AI-Humanoid-Robotics-Textbook/tree/main/my-website/docs/module2/chapter2-gazebo-physics.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2,"title":"Chapter 2: Gazebo Physics Engine","module":2,"chapter":2,"id":"ch2-gazebo-physics","learning_objectives":["Understand how physics engines simulate realistic robot behavior","Compare different physics engines (ODE, Bullet, DART, Ignition)","Configure physics parameters for accurate simulation"],"prerequisites":["Chapter 1: Digital Twin Fundamentals completed","Module 1: ROS 2 Fundamentals"],"related_chapters":["chapter1-digital-twin-concepts","chapter3-world-building","chapter4-sensor-simulation"],"keywords":["physics engine","Gazebo","ODE","collision detection","gravity"],"difficulty":"Intermediate","estimated_reading_time":"22 minutes","estimated_word_count":3000,"created_at":"2025-12-09","chunk_count":6,"searchable_terms":["physics engine","Gazebo","ODE","Bullet","DART"]},"sidebar":"docs","previous":{"title":"Chapter 1: Digital Twin Fundamentals","permalink":"/Physical-AI-Humanoid-Robotics-Textbook/docs/module2/ch1-digital-twin-concepts"},"next":{"title":"Chapter 3: Building Custom Worlds","permalink":"/Physical-AI-Humanoid-Robotics-Textbook/docs/module2/ch3-world-building"}}');var t=i(4848),r=i(8453);const o={sidebar_position:2,title:"Chapter 2: Gazebo Physics Engine",module:2,chapter:2,id:"ch2-gazebo-physics",learning_objectives:["Understand how physics engines simulate realistic robot behavior","Compare different physics engines (ODE, Bullet, DART, Ignition)","Configure physics parameters for accurate simulation"],prerequisites:["Chapter 1: Digital Twin Fundamentals completed","Module 1: ROS 2 Fundamentals"],related_chapters:["chapter1-digital-twin-concepts","chapter3-world-building","chapter4-sensor-simulation"],keywords:["physics engine","Gazebo","ODE","collision detection","gravity"],difficulty:"Intermediate",estimated_reading_time:"22 minutes",estimated_word_count:3e3,created_at:"2025-12-09",chunk_count:6,searchable_terms:["physics engine","Gazebo","ODE","Bullet","DART"]},l="Chapter 2: Gazebo Physics Engine",c={},a=[{value:"How Physics Engines Work",id:"how-physics-engines-work",level:2},{value:"Physics Engines in Gazebo",id:"physics-engines-in-gazebo",level:2},{value:"Physics Engine Comparison Diagram",id:"physics-engine-comparison-diagram",level:3},{value:"Core Physics Parameters",id:"core-physics-parameters",level:2},{value:"Gravity",id:"gravity",level:3},{value:"Mass and Inertia",id:"mass-and-inertia",level:3},{value:"Friction Models",id:"friction-models",level:3},{value:"Physics Timestep",id:"physics-timestep",level:3},{value:"Realistic Simulation: Configuration Example",id:"realistic-simulation-configuration-example",level:2},{value:"Step 1: Set Gravity",id:"step-1-set-gravity",level:3},{value:"Step 2: Configure Contact Solver",id:"step-2-configure-contact-solver",level:3},{value:"Step 3: Define Floor Friction",id:"step-3-define-floor-friction",level:3},{value:"Step 4: Configure Robot (URDF)",id:"step-4-configure-robot-urdf",level:3},{value:"Common Physics Issues and Solutions",id:"common-physics-issues-and-solutions",level:2},{value:"Problem 1: Robot Falls Through Floor",id:"problem-1-robot-falls-through-floor",level:3},{value:"Problem 2: Robot Vibrates or Explodes",id:"problem-2-robot-vibrates-or-explodes",level:3},{value:"Problem 3: Simulation Runs Slowly",id:"problem-3-simulation-runs-slowly",level:3},{value:"Real-World Scenario: Humanoid Standing in Gazebo",id:"real-world-scenario-humanoid-standing-in-gazebo",level:2},{value:"Initial State",id:"initial-state",level:3},{value:"Physics Calculation",id:"physics-calculation",level:3},{value:"Realistic Outcome",id:"realistic-outcome",level:3},{value:"Unrealistic Scenario (Common Error)",id:"unrealistic-scenario-common-error",level:3},{value:"Tuning Physics for Your Robot",id:"tuning-physics-for-your-robot",level:2},{value:"Step 1: Start with Defaults",id:"step-1-start-with-defaults",level:3},{value:"Step 2: Test Basic Stability",id:"step-2-test-basic-stability",level:3},{value:"Step 3: Test Friction",id:"step-3-test-friction",level:3},{value:"Step 4: Test Motion",id:"step-4-test-motion",level:3},{value:"Step 5: Performance Tuning",id:"step-5-performance-tuning",level:3},{value:"Cross-Module Connections",id:"cross-module-connections",level:2},{value:"SDF Format: World Files",id:"sdf-format-world-files",level:2},{value:"Key Takeaways",id:"key-takeaways",level:2},{value:"Acronym Reference",id:"acronym-reference",level:2},{value:"Next: Chapter 3",id:"next-chapter-3",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"chapter-2-gazebo-physics-engine",children:"Chapter 2: Gazebo Physics Engine"})}),"\n",(0,t.jsx)(n.h2,{id:"how-physics-engines-work",children:"How Physics Engines Work"}),"\n",(0,t.jsxs)(n.p,{children:["A ",(0,t.jsx)(n.strong,{children:"physics engine"})," is software that simulates how objects move and interact in a virtual world. In Gazebo, the physics engine calculates:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Gravity"}),": How fast objects fall"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Collisions"}),": When objects bump into each other"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Friction"}),": How much objects slide on surfaces"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Contact forces"}),": How hard surfaces push back on objects"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Without a physics engine, a robot in simulation would just hang in mid-air. With it, the robot falls realistically, stands on the ground, and interacts properly with objects."}),"\n",(0,t.jsx)(n.h2,{id:"physics-engines-in-gazebo",children:"Physics Engines in Gazebo"}),"\n",(0,t.jsx)(n.p,{children:"Gazebo supports multiple physics engines:"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Engine"}),(0,t.jsx)(n.th,{children:"Speed"}),(0,t.jsx)(n.th,{children:"Accuracy"}),(0,t.jsx)(n.th,{children:"Use Case"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"ODE"})}),(0,t.jsx)(n.td,{children:"Fast"}),(0,t.jsx)(n.td,{children:"Good"}),(0,t.jsx)(n.td,{children:"Default, general robotics"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Bullet"})}),(0,t.jsx)(n.td,{children:"Fast"}),(0,t.jsx)(n.td,{children:"Very Good"}),(0,t.jsx)(n.td,{children:"Better stability, contacts"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"DART"})}),(0,t.jsx)(n.td,{children:"Slower"}),(0,t.jsx)(n.td,{children:"Excellent"}),(0,t.jsx)(n.td,{children:"Research, humanoids (best inertia handling)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Ignition Physics"})}),(0,t.jsx)(n.td,{children:"Very Fast"}),(0,t.jsx)(n.td,{children:"Good"}),(0,t.jsx)(n.td,{children:"Ignition Gazebo (next-gen)"})]})]})]}),"\n",(0,t.jsxs)(n.p,{children:["For most robotics, ",(0,t.jsx)(n.strong,{children:"ODE"})," or ",(0,t.jsx)(n.strong,{children:"Bullet"})," are excellent choices. ",(0,t.jsx)(n.strong,{children:"DART"})," is best if your humanoid has complex joint interactions."]}),"\n",(0,t.jsx)(n.h3,{id:"physics-engine-comparison-diagram",children:"Physics Engine Comparison Diagram"}),"\n",(0,t.jsx)(n.mermaid,{value:'graph TD\n    A["Choose Physics Engine"] --\x3e B{"Humanoid\\nwith Complex\\nJoints?"}\n    B --\x3e|Yes| C["DART\\n(Best inertia handling)"]\n    B --\x3e|No| D{"Need Best\\nStability?"}\n    D --\x3e|Yes| E["Bullet\\n(Excellent contacts)"]\n    D --\x3e|No| F["ODE\\n(Default, fast)"]\n\n    C --\x3e G["Research-grade\\nSimulation"]\n    E --\x3e H["Stable contacts\\nGood accuracy"]\n    F --\x3e I["Fast, good\\nfor development"]\n\n    style C fill:#ffcc99\n    style E fill:#99ccff\n    style F fill:#99ff99'}),"\n",(0,t.jsx)(n.h2,{id:"core-physics-parameters",children:"Core Physics Parameters"}),"\n",(0,t.jsx)(n.p,{children:"Let's understand the main settings that affect how simulation behaves:"}),"\n",(0,t.jsx)(n.h3,{id:"gravity",children:"Gravity"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'Gravity on Earth: 9.81 m/s\xb2\n\nIn Gazebo world file:\n<gravity x="0" y="0" z="-9.81"/>\n\nWhat this means:\n- Negative Z means "down"\n- Value -9.81 means standard Earth gravity\n- Change to -4.9 for half-gravity, -0 for no gravity\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Why change gravity?"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Test robot on Moon (-1.6 m/s\xb2)"}),"\n",(0,t.jsx)(n.li,{children:"Test on Mars (-3.7 m/s\xb2)"}),"\n",(0,t.jsx)(n.li,{children:"Slow-motion testing (reduce gravity)"}),"\n",(0,t.jsx)(n.li,{children:"Exaggerate effects (increase gravity)"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"mass-and-inertia",children:"Mass and Inertia"}),"\n",(0,t.jsxs)(n.p,{children:["Every object has ",(0,t.jsx)(n.strong,{children:"mass"})," (how heavy) and ",(0,t.jsx)(n.strong,{children:"inertia"})," (resistance to rotation):"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'<link name="gripper">\n  <inertial>\n    <mass>2.5</mass>  \x3c!-- 2.5 kg --\x3e\n    <inertia>\n      \x3c!-- Defines how hard it is to rotate around each axis --\x3e\n      <ixx>0.01</ixx>  \x3c!-- Around X axis --\x3e\n      <iyy>0.01</iyy>  \x3c!-- Around Y axis --\x3e\n      <izz>0.01</izz>  \x3c!-- Around Z axis --\x3e\n    </inertia>\n  </inertial>\n</link>\n'})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Critical for realism"}),": Inertia must match the actual object's shape. A long, thin object spins easily around its length but resists spinning around its width."]}),"\n",(0,t.jsx)(n.h3,{id:"friction-models",children:"Friction Models"}),"\n",(0,t.jsx)(n.p,{children:"Friction determines how much objects slide on surfaces:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"Low Friction (ice):\n- Objects slide easily\n- Robot feet slip\n- Unstable standing\n\nHigh Friction (rubber on concrete):\n- Objects grip well\n- Robot feet stable\n- Realistic traction\n"})}),"\n",(0,t.jsx)(n.p,{children:"Configure in SDF:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"<surface>\n  <friction>\n    <mu>0.5</mu>    \x3c!-- Coefficient of friction (higher = more grip) --\x3e\n    <mu2>0.5</mu2>  \x3c!-- Friction in other direction --\x3e\n  </friction>\n</surface>\n"})}),"\n",(0,t.jsx)(n.h3,{id:"physics-timestep",children:"Physics Timestep"}),"\n",(0,t.jsxs)(n.p,{children:["The physics engine calculates motion in discrete ",(0,t.jsx)(n.strong,{children:"timesteps"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"Timestep = 0.001 seconds (1 millisecond)\n\nAt each timestep:\n1. Apply forces (gravity, motors)\n2. Detect collisions\n3. Resolve contacts\n4. Update positions\n\nSmaller timestep \u2192 More accurate but slower\nLarger timestep \u2192 Faster but less accurate\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Typical values"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"0.001"})," (1ms): High accuracy, slower simulation"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"0.004"})," (4ms): Good balance (ROS 2 control loops usually 1-10ms)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"0.01"})," (10ms): Lower accuracy, faster"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"realistic-simulation-configuration-example",children:"Realistic Simulation: Configuration Example"}),"\n",(0,t.jsx)(n.p,{children:"Let's walk through configuring a realistic simulation for a humanoid robot:"}),"\n",(0,t.jsx)(n.h3,{id:"step-1-set-gravity",children:"Step 1: Set Gravity"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml",children:'<world name="default">\n  <gravity x="0" y="0" z="-9.81"/>\n  <physics name="default_physics" default="0" type="ode">\n    <max_step_size>0.001</max_step_size>\n    <real_time_factor>1.0</real_time_factor>\n  </physics>\n</world>\n'})}),"\n",(0,t.jsx)(n.h3,{id:"step-2-configure-contact-solver",children:"Step 2: Configure Contact Solver"}),"\n",(0,t.jsx)(n.p,{children:"How Gazebo resolves collisions:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml",children:"<physics>\n  <ode>\n    <solver>\n      <type>quick</type>  \x3c!-- faster but less accurate --\x3e\n      <iters>50</iters>   \x3c!-- iterations per step (higher = more accurate) --\x3e\n    </solver>\n    <constraints>\n      <cfm>0</cfm>        \x3c!-- Contact constraint softness --\x3e\n      <erp>0.2</erp>      \x3c!-- Error reduction parameter --\x3e\n    </constraints>\n  </ode>\n</physics>\n"})}),"\n",(0,t.jsx)(n.h3,{id:"step-3-define-floor-friction",children:"Step 3: Define Floor Friction"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml",children:'<model name="ground_plane">\n  <link name="link">\n    <collision name="collision">\n      <geometry>\n        <plane><normal>0 0 1</normal></plane>\n      </geometry>\n      <surface>\n        <friction>\n          <mu>1.0</mu>    \x3c!-- Concrete floor --\x3e\n          <mu2>1.0</mu2>\n        </friction>\n        <contact>\n          <max_vel>0.1</max_vel>\n          <min_depth>0.001</min_depth>\n        </contact>\n      </surface>\n    </collision>\n  </link>\n</model>\n'})}),"\n",(0,t.jsx)(n.h3,{id:"step-4-configure-robot-urdf",children:"Step 4: Configure Robot (URDF)"}),"\n",(0,t.jsx)(n.p,{children:"Load your robot with correct mass and inertia:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml",children:'<link name="torso">\n  <inertial>\n    <mass>15.0</mass>  \x3c!-- Humanoid torso mass --\x3e\n    <inertia>\n      <ixx>0.5</ixx>\n      <iyy>0.5</iyy>\n      <izz>0.4</izz>\n    </inertia>\n  </inertial>\n  <collision>\n    <geometry>\n      <box size="0.3 0.3 0.5"/>  \x3c!-- Collision shape --\x3e\n    </geometry>\n  </collision>\n</link>\n'})}),"\n",(0,t.jsx)(n.h2,{id:"common-physics-issues-and-solutions",children:"Common Physics Issues and Solutions"}),"\n",(0,t.jsx)(n.h3,{id:"problem-1-robot-falls-through-floor",children:"Problem 1: Robot Falls Through Floor"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Symptom"}),": In Gazebo, robot sinks into ground instead of standing"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Causes"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Collision geometry not defined for robot"}),"\n",(0,t.jsx)(n.li,{children:"Floor friction too low"}),"\n",(0,t.jsx)(n.li,{children:"Physics timestep too large"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Solution"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml",children:'\x3c!-- Add collision to robot links --\x3e\n<collision name="collision">\n  <geometry>\n    <box size="..."/>\n  </geometry>\n</collision>\n\n\x3c!-- Increase floor friction --\x3e\n<mu>1.5</mu>\n\n\x3c!-- Reduce timestep --\x3e\n<max_step_size>0.001</max_step_size>\n'})}),"\n",(0,t.jsx)(n.h3,{id:"problem-2-robot-vibrates-or-explodes",children:"Problem 2: Robot Vibrates or Explodes"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Symptom"}),": Robot shakes violently or parts fly apart"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Causes"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Physics timestep too large"}),"\n",(0,t.jsx)(n.li,{children:"Contact stiffness too high"}),"\n",(0,t.jsx)(n.li,{children:"Inertia values incorrect"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Solution"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml",children:"\x3c!-- Reduce timestep --\x3e\n<max_step_size>0.0005</max_step_size>\n\n\x3c!-- Increase solver iterations --\x3e\n<iters>100</iters>\n\n\x3c!-- Soften contact (increase CFM) --\x3e\n<cfm>0.00001</cfm>\n"})}),"\n",(0,t.jsx)(n.h3,{id:"problem-3-simulation-runs-slowly",children:"Problem 3: Simulation Runs Slowly"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Symptom"}),": Real-time factor < 0.5 (simulation slower than real-time)"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Causes"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Too many objects/complexity"}),"\n",(0,t.jsx)(n.li,{children:"Timestep too small"}),"\n",(0,t.jsx)(n.li,{children:"Complex mesh collisions"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Solution"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml",children:'\x3c!-- Increase timestep (less accurate but faster) --\x3e\n<max_step_size>0.002</max_step_size>\n\n\x3c!-- Use simpler collision geometries --\x3e\n\x3c!-- Instead of: <mesh>complex_model.dae</mesh> --\x3e\n\x3c!-- Use: <box size="0.5 0.3 0.2"/> --\x3e\n\n\x3c!-- Reduce solver iterations --\x3e\n<iters>20</iters>\n'})}),"\n",(0,t.jsx)(n.h2,{id:"real-world-scenario-humanoid-standing-in-gazebo",children:"Real-World Scenario: Humanoid Standing in Gazebo"}),"\n",(0,t.jsx)(n.p,{children:"Let's trace how physics makes a humanoid robot stand realistically:"}),"\n",(0,t.jsx)(n.h3,{id:"initial-state",children:"Initial State"}),"\n",(0,t.jsx)(n.p,{children:"Robot is dropped into simulation at time t=0"}),"\n",(0,t.jsx)(n.h3,{id:"physics-calculation",children:"Physics Calculation"}),"\n",(0,t.jsx)(n.p,{children:"At each timestep (1ms):"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Gravity acts"}),": Robot falls downward"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Feet collide with floor"}),": Physics engine detects collision"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Contact force calculated"}),": Normal force equals robot weight"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Friction applied"}),": Friction force prevents feet from sliding"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Robot accelerates upward"}),": Collision stops falling"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Result"}),": Robot oscillates until resting on floor"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"realistic-outcome",children:"Realistic Outcome"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"Time 0.0s: Robot dropped\nTime 0.1s: Robot has fallen 0.05m (gravity accelerating it)\nTime 0.2s: Robot feet touch floor (collision detected)\nTime 0.25s: Robot stops sinking (equilibrium reached)\nTime 0.3s: Robot slightly compressed, stabilizes\nTime 0.5s: Robot standing stably on floor\n"})}),"\n",(0,t.jsx)(n.h3,{id:"unrealistic-scenario-common-error",children:"Unrealistic Scenario (Common Error)"}),"\n",(0,t.jsx)(n.p,{children:"If inertia is wrong:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"Time 0.0s: Robot dropped\nTime 0.2s: Robot falls through floor (no collision)\nResult: FAIL - robot disappears!\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Solution"}),": Check URDF has correct collision geometry and inertia values."]}),"\n",(0,t.jsx)(n.h2,{id:"tuning-physics-for-your-robot",children:"Tuning Physics for Your Robot"}),"\n",(0,t.jsx)(n.p,{children:"Here's a systematic approach:"}),"\n",(0,t.jsx)(n.h3,{id:"step-1-start-with-defaults",children:"Step 1: Start with Defaults"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml",children:"<max_step_size>0.001</max_step_size>\n<real_time_factor>1.0</real_time_factor>\n<iters>50</iters>\n"})}),"\n",(0,t.jsx)(n.h3,{id:"step-2-test-basic-stability",children:"Step 2: Test Basic Stability"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Drop robot in Gazebo"}),"\n",(0,t.jsx)(n.li,{children:"Does it stand without falling through floor?"}),"\n",(0,t.jsx)(n.li,{children:"If yes \u2192 proceed"}),"\n",(0,t.jsx)(n.li,{children:"If no \u2192 check collision geometry"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"step-3-test-friction",children:"Step 3: Test Friction"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Apply small horizontal force to robot"}),"\n",(0,t.jsx)(n.li,{children:"Does it slip or resist?"}),"\n",(0,t.jsxs)(n.li,{children:["Adjust ",(0,t.jsx)(n.code,{children:"<mu>"})," until behavior matches real robot"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"step-4-test-motion",children:"Step 4: Test Motion"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Command robot to walk"}),"\n",(0,t.jsx)(n.li,{children:"Does it maintain balance?"}),"\n",(0,t.jsx)(n.li,{children:"Does it recover from small pushes?"}),"\n",(0,t.jsx)(n.li,{children:"Adjust inertia if wobbly"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"step-5-performance-tuning",children:"Step 5: Performance Tuning"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Check real-time factor"}),"\n",(0,t.jsx)(n.li,{children:"If < 0.8 \u2192 increase timestep or simplify world"}),"\n",(0,t.jsx)(n.li,{children:"If > 1.0 and shaky \u2192 decrease timestep"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"cross-module-connections",children:"Cross-Module Connections"}),"\n",(0,t.jsx)(n.p,{children:"Physics simulation enables multiple downstream capabilities:"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"From Module 1 (ROS 2 Fundamentals)"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"URDF files"})," (Module 1, Chapter 3) define robot mass and inertia used by physics engine"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"ROS 2 topics"})," (Module 1, Chapter 1) publish sensor readings generated by physics simulation"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Autonomous agents"})," (Module 1, Chapter 2) receive physics-based feedback for decision-making"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"To Module 3 (Isaac Sim & Perception)"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Physics accuracy determines ",(0,t.jsx)(n.strong,{children:"sensor simulation realism"})," (Chapter 4 here)"]}),"\n",(0,t.jsx)(n.li,{children:"Learned perception models from Chapter 4's synthetic data depend on accurate physics"}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"VSLAM and navigation"})," in Module 3 require realistic robot dynamics"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"To Module 4 (VLA Pipeline)"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Manipulation tasks"})," in Module 4 depend on accurate ",(0,t.jsx)(n.strong,{children:"friction and contact forces"})," (this chapter)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Grasping strategies"})," must account for physics parameters: mass, inertia, friction"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Motion constraints"})," learned in simulation must match real robot physics"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"sdf-format-world-files",children:"SDF Format: World Files"}),"\n",(0,t.jsxs)(n.p,{children:["Gazebo worlds are described in ",(0,t.jsx)(n.strong,{children:"SDF (Simulation Description Format)"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml",children:"<?xml version='1.0'?>\n<sdf version='1.7'>\n  <world name='default'>\n    \x3c!-- Gravity configuration --\x3e\n    <gravity x='0' y='0' z='-9.81'/>\n\n    \x3c!-- Physics engine --\x3e\n    <physics name='default_physics' default='0' type='ode'>\n      <max_step_size>0.001</max_step_size>\n      <real_time_factor>1.0</real_time_factor>\n      <ode>\n        <solver>\n          <type>quick</type>\n          <iters>50</iters>\n        </solver>\n      </ode>\n    </physics>\n\n    \x3c!-- Models in world --\x3e\n    <model name='ground_plane'>\n      \x3c!-- ... collision, friction, etc ... --\x3e\n    </model>\n\n    <include>\n      <uri>model://my_robot</uri>\n      <pose>0 0 0 0 0 0</pose>\n    </include>\n  </world>\n</sdf>\n"})}),"\n",(0,t.jsx)(n.h2,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,t.jsxs)(n.p,{children:["\u2713 ",(0,t.jsx)(n.strong,{children:"Physics engines"})," simulate gravity, collisions, friction realistically\n\u2713 ",(0,t.jsx)(n.strong,{children:"Gazebo supports"})," ODE, Bullet, DART engines (choose based on needs)\n\u2713 ",(0,t.jsx)(n.strong,{children:"Configuration matters"}),": Gravity, mass, inertia, friction affect realism\n\u2713 ",(0,t.jsx)(n.strong,{children:"Timestep trade-off"}),": Smaller = more accurate but slower\n\u2713 ",(0,t.jsx)(n.strong,{children:"Common issues"}),": Robot sinking, vibrating, running slowly (solutions provided)\n\u2713 ",(0,t.jsx)(n.strong,{children:"SDF files"})," describe worlds in XML format\n\u2713 ",(0,t.jsx)(n.strong,{children:"Tuning is iterative"}),": Test, observe, adjust parameters"]}),"\n",(0,t.jsx)(n.h2,{id:"acronym-reference",children:"Acronym Reference"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Acronym"}),(0,t.jsx)(n.th,{children:"Full Name"}),(0,t.jsx)(n.th,{children:"Definition"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"ODE"})}),(0,t.jsx)(n.td,{children:"Open Dynamics Engine"}),(0,t.jsx)(n.td,{children:"Open-source physics engine optimized for real-time robotics"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Bullet"})}),(0,t.jsx)(n.td,{children:"Bullet Physics Engine"}),(0,t.jsx)(n.td,{children:"High-performance physics engine with excellent contact handling"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"DART"})}),(0,t.jsx)(n.td,{children:"Dynamic Animation and Robotics Toolkit"}),(0,t.jsx)(n.td,{children:"Research physics engine with superior humanoid inertia handling"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Ignition"})}),(0,t.jsx)(n.td,{children:"Ignition Gazebo"}),(0,t.jsx)(n.td,{children:"Next-generation Gazebo with high-performance physics backend"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Physics"})}),(0,t.jsx)(n.td,{children:"Physical Simulation"}),(0,t.jsx)(n.td,{children:"Computational modeling of real-world forces and interactions"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"GPU"})}),(0,t.jsx)(n.td,{children:"Graphics Processing Unit"}),(0,t.jsx)(n.td,{children:"Specialized hardware for accelerating physics calculations"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"CPU"})}),(0,t.jsx)(n.td,{children:"Central Processing Unit"}),(0,t.jsx)(n.td,{children:"Main processor for general physics simulation"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Friction"})}),(0,t.jsx)(n.td,{children:"Surface Resistance"}),(0,t.jsx)(n.td,{children:"Force opposing relative motion between surfaces (coefficient \u03bc)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Inertia"})}),(0,t.jsx)(n.td,{children:"Rotational Resistance"}),(0,t.jsx)(n.td,{children:"Resistance to angular acceleration around each axis"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Contact"})}),(0,t.jsx)(n.td,{children:"Collision Response"}),(0,t.jsx)(n.td,{children:"Forces generated when objects collide in simulation"})]})]})]}),"\n",(0,t.jsx)(n.h2,{id:"next-chapter-3",children:"Next: Chapter 3"}),"\n",(0,t.jsxs)(n.p,{children:["Now that you understand physics, let's ",(0,t.jsx)(n.strong,{children:"build realistic worlds"}),". In ",(0,t.jsx)(n.strong,{children:"Chapter 3: Building Custom Worlds"}),", you'll create Gazebo environments with obstacles, objects, and varying terrain for your robot to navigate."]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Learning Outcome"}),": You can now configure realistic physics in Gazebo, understand the trade-offs between accuracy and speed, and troubleshoot common physics simulation problems."]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>l});var s=i(6540);const t={},r=s.createContext(t);function o(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);